import java.io.FileNotFoundException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.LinkedHashMap;import java.lang.Math;public class Fund {    private String filePath;    private LinkedHashMap<String, Double> rawHistoricalPrices;    private LinkedHashMap<String, Double> cutHistoricalPrices;    private LinkedHashMap<String, Double> returns;    private LinkedHashMap<String,Double> distances;    private double mean;    private double sigma;    private double weight;    private double beta;    private boolean inclusionInDownload = false;    private boolean inclusionInPortfolio = false;    private boolean inclusionInEfficientFrontier = false;    private String name;    private String ticker;    private String fundFamily;    private Date startDate;    private Date endDate;    private double annualizedReturn;    private double annualizedRisk;    SimpleDateFormat formatter;    private double efLowerBound;    private double efUpperBound;    private double minWeight;    private double maxWeight;    private double optimalWeight;    public Fund(String ticker, String name, String fundFamily){        this.ticker = ticker;        this.name = name;        this.fundFamily = fundFamily;        formatter = new SimpleDateFormat("yyyy-MM-dd");        efLowerBound = 0.0;        efUpperBound = 1.0;        minWeight    = 0.0;        maxWeight    = 1.0;    }    public void calculateFundRiskReturn(LinkedHashMap<String, Double> historicalPrices){        calculateReturns(historicalPrices);        calculateReturnMean(returns);        calculateDistanceFromMean(returns);        calculateStandardDeviation(distances);    }    public void readHistoricalPrices(String csvFilePath){        Parser p = new Parser();        try{            p.parseCSV(csvFilePath);        }        catch(FileNotFoundException e){            System.out.println("File not found");        }        rawHistoricalPrices = p.getDictionary();    }    //could this method be split into two? createDateArray, createPriceArray, calculateReturn?    private LinkedHashMap<String,Double> calculateReturns(LinkedHashMap<String, Double> historicalPrices){        returns = new LinkedHashMap<>();        ArrayList<String> dateArray = new ArrayList<>(historicalPrices.keySet());        ArrayList<Double> priceArray = new ArrayList<>(historicalPrices.values());        //calculation        for (int i=1; i<historicalPrices.size(); i++){            double begPrice = priceArray.get(i-1);            returns.put(dateArray.get(i), (priceArray.get(i)-begPrice)/begPrice);        }        return returns;    }    private double calculateReturnMean(LinkedHashMap<String,Double> returns){        mean=0;        for (double i : returns.values()){            mean+=i;        }        mean = mean/returns.size();        return mean;    }    private double calculateStandardDeviation(LinkedHashMap<String,Double> distances){        sigma=0;        int n = distances.size();        for (double i : distances.values()){            sigma += (Math.pow(i,2));        }        sigma = Math.sqrt(sigma/(n-1));        return sigma;    }    public double calculateAnnualizedRisk(){        annualizedRisk = sigma * Math.sqrt(12);        return annualizedRisk;    }    public double calculateAnnualizedReturn(){        annualizedReturn = Math.pow(mean+1, 12)-1;        return annualizedReturn;    }    private LinkedHashMap<String,Double> calculateDistanceFromMean(LinkedHashMap<String,Double> returns){        distances = new LinkedHashMap<>();        returns.forEach((key,value) -> distances.put(key,(value-mean)));        return distances;    }    public Double calculateBeta(Fund marketBenchmark){        beta = 0;        Covariance covariance = new Covariance(this, marketBenchmark);        double variance = Math.pow(marketBenchmark.sigma,2);        beta = covariance.calculateCovariance() / variance;        return beta;    }    public void deleteData(){        rawHistoricalPrices = null;        returns = null;        distances = null;        mean = 0;        sigma = 0;        weight = 0;        inclusionInDownload = false;        inclusionInPortfolio = false;        inclusionInEfficientFrontier = false;        startDate = null;        endDate = null;        annualizedReturn = 0;        annualizedRisk = 0;    }    public void clearRiskReturnBetaWeight(){        annualizedReturn = 0;        annualizedRisk = 0;    }    //Setter Methods    public void setWeight(double a){        weight = a;    }    public void toggleInclusionInDownload(){ inclusionInDownload = !inclusionInDownload;}    public void toggleInclusionInPortfolio(){ inclusionInPortfolio = !inclusionInPortfolio;}    public void toggleInclusionInEfficientFrontier(){ inclusionInEfficientFrontier = !inclusionInEfficientFrontier;}    public void setRawHistoricalPrices(LinkedHashMap<String,Double> newRawHistoricalPrices){        rawHistoricalPrices = newRawHistoricalPrices;    }    public void setCutHistoricalPrices(LinkedHashMap<String, Double> cutHistoricalPrices) {        this.cutHistoricalPrices = cutHistoricalPrices;    }    public void setStartDate() {        ArrayList<String> dates = new ArrayList<>(rawHistoricalPrices.keySet());        try {            startDate = formatter.parse(dates.get(0));        } catch (ParseException e) {            e.printStackTrace();        }    }    public void setEndDate() {        ArrayList<String> dates = new ArrayList<>(rawHistoricalPrices.keySet());        try {            endDate = formatter.parse(dates.get(dates.size()-1));        } catch (ParseException e) {            e.printStackTrace();        }    }    public void setFilePath(String filePath){        this.filePath = filePath;    }    public void setEfLowerBound(Double efLowerBound){        this.efLowerBound = efLowerBound;    }    public void setEfUpperBound(Double efUpperBound){        this.efUpperBound = efUpperBound;    }    public void setOptimalWeight(double optimalWeight) {        this.optimalWeight = optimalWeight;    }    public void setMaxWeight(double maxWeight) {        this.maxWeight = maxWeight;    }    public void setMinWeight(double minWeight) {        this.minWeight = minWeight;    }    //Getter Methods    public LinkedHashMap<String, Double> getRawHistoricalPrices() {        return rawHistoricalPrices;    }    public LinkedHashMap<String, Double> getCutHistoricalPrices() {        return cutHistoricalPrices;    }    public LinkedHashMap<String, Double> getReturnPrices(){        return returns;    }    public double getBeta(){        return beta;    }    public double getSigma(){        return sigma;    }    public double getMean(){        return mean;    }    public double getWeight() {        return weight;    }    public String getName(){        return name;    }    public String getTicker(){        return ticker;    }    public LinkedHashMap<String,Double> getDistances(){        return distances;    }    public double getAnnualizedReturn(){        return annualizedReturn;    }    public double getAnnualizedRisk(){        return annualizedRisk;    }    public boolean getInclusionInDownload(){        return inclusionInDownload;    }    public boolean getInclusionInPortfolio(){        return inclusionInPortfolio;    }    public boolean getInclusionInEfficientFrontier(){        return inclusionInEfficientFrontier;    }    public String getFundFamily(){        return fundFamily;    }    public String getStartDateString(){        if (startDate == null){            return "";        }        else{            return formatter.format(startDate);        }    }    public String getEndDateString(){        if (endDate == null){            return "";        }        else{            return formatter.format(endDate);        }    }    public Date getStartDate(){        return startDate;    }    public Date getEndDate(){        return endDate;    }    public String getAbsolutePath(){        return filePath;    }    public boolean hasHistoricalData(){        return rawHistoricalPrices != null;    }    public double getEfLowerBound(){        return efLowerBound;    }    public double getEfUpperBound(){        return efUpperBound;    }    public Double getOptimalWeight() {        return optimalWeight;    }    public Double getMaxWeight() {        return maxWeight;    }    public Double getMinWeight() {        return minWeight;    }    @Override    public String toString(){        return ticker + " | " + name;    }}